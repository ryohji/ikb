http://www.linuxforums.org/articles/understanding-elf-using-readelf-and-objdump_125.html
Understanding ELF using readelf and objdump

ELF とは何でしょうか。　ELF (Executable and Linking Format) はファイル形式で、オブジェクトファイルの構成や順序を定めています。　この情報をもとにカーネルやバイナリーローダーは、ファイルをロードする方法や、コードをどこから探すか、初期化データはどこにあるか、必要な共有ライブラリーはどれか、といったことを知るのです。

まず最初に、種々の ELF オブジェクトを知らねばなりません。

・Relocatable file (再配置可能ファイル)：　コードやデータを保持し、ほかのオブジェクトファイルとリンクして実行可能形式や共有オブジェクトファイルを作成することに適しています。　つまり、 relocatable ファイルは実行可能形式 (Executable) やライブラリーを作成する基盤です。
これらのファイルはソースコードをコンパイルすることで得られます。：

$ gcc -c test.c

これで実行可能形式の test.o が生成されます。
カーネルモジュール (.o や .ko の拡張子) も relocatable file の形式です。

・Executable file (実行可能ファイル)：　実行できるプログラムを格納したオブジェクトファイルです。　そう、 XMMS mp3 プレイヤーや vcd ソフトウェアプレイヤー、テキストエディターもすべて ELF executable ファイルです。
プログラムをコンパイルしたことのあるあなたには、これまた馴染みのファイルです。：

$ gcc -o test test.c

"test" ファイルの実行可能ビットが有効になっていれば実行できます。　ではシェルスクリプトはどうなのでしょう？　シェルスクリプトは ELF 実行可能形式ではなく、インタープリターです。

・Shared object file (共有オブジェクトファイル)：　これはふたつのコンテキストでリンク可能な、コードとデータを保持します。
1. リンクエディターが処理し、ほかの再配置可能な共有オブジェクトファイルとあわせて別のオブジェクトファイルつくります。
2. ダイナミックリンカーが、実行可能ファイルやほかの共有オブジェクトと組み合わせてプロセスイメージにします。
簡単に言えば .so の拡張子がついたファイルです。（ほとんどの Linux で /usr/lib に配置されています）


ELF 形式をしらべるほかの方法はあるでしょうか？　ええ、あります。　すべての ELF オブジェクトにはファイルヘッダーがついており、このファイルが何なのかが書かれています。　 binutils パッケージがインストールされているならば、 readelf でこのヘッダーを読めます。　たとえばこんな具合です（コマンドの実行結果は関連するフィールドのみを取り出し、短くしてあります）：

$ readelf -h /bin/ls
Type: EXEC (Executable file)
$ readelf -h /usr/lib/crt1.o
Type: REL (Relocatable file)
$ readefl -h /lib/libc-2.3.2.so
Type: DYN (Shared object file)

"File" コマンドもオブジェクトファイルの同定に役立ちますが、ここでは詳細には触れません。　これから使うことになる readelf と objdump に焦点をしぼりましょう。

ELF を簡単に調べられるよう、次のシンプルな C プログラムをつかいましょう。：

/* test.c */
#include <stdio.h>
int global_data = 4;
int global_data_2;
int main(int argc, char **argv) {
  int local_data = 3;
  printf("Hello Worldn");
  printf("global_data = %dn", global_data);
  printf("global_data_2 = %dn", global_data_2);
  printf("local_data = %dn", local_data);
  return (0);
}

そしてコンパイルしてみます。：

$ gcc -o test test.c


A. ELF ヘッダーを調べる

できあがったバイナリーが、これから調べる対象です。　まず ELF ヘッダーの中身を見てみましょう。

$ readelf -h test
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x80482c0
  Start of program headers:          52 (bytes into file)
  Start of section headers:          2060 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         7
  Size of section headers:           40 (bytes)
  Number of section headers:         28
  Section header string table index: 25

このヘッダーは何を意味するのでしょうか？

・この実行可能形式は Intel x86 32bit アーキテクチャー用です。 ("machine" と "class" フィールド)
・実行時にプログラムは 0x80482c0 (entry point address です)。　"0x" の前置はこれが16進数であることを示しています。　このアドレスは main 関数でなく _start という名前の関数を指しています。　つくった覚えがないですか？　もちろん、つくっていません。　_start 関数はリンカーが生成したもので、プログラムを初期化するものです。
・このプログラムには、ぜんぶで 28 のセクションと 7 つのセグメントがあります。

セクションとはなんでしょう？　セクションはオブジェクトファイルの一領域で、リンク時に役立つ情報が書かれています。：　プログラムのコードそのもの、プログラムのデータ（変数や配列、文字列）、再配置情報やその他もろもろ。　つまり、それぞれの領域には、いくつかの情報がグループ化されていて、おのおの異なる意味をもっています。：　コードセクションはコードのみを持ち、データセクションは初期化済みあるいは未初期化のデータを抱える、といった具合です。　セクションヘッダーテーブル (SHT) は、 ELF オブジェクトにあるセクションを正確にあらわしますが、さきに見た "Number of section headers" では "test" に 28 のセクションがあることしかわかりません。

セクションがバイナリー上で意味をもつとしても、 Linux カーネルは同じようにはとらえていません。　Linux カーネルはいくつかの VMA (Virtual memory area) を用意します。　VMA には実質的に連続したページフレームが格納されます。　これらの VMA の中にひとつ、あるいはそれ以上のセクションがマッピングされます。　ここでの各 VMA は、それぞれが ELF セグメントにあたります。　カーネルはどのセクションがどのセグメントに行くかをどのように決めるのでしょうか？　ここでプログラムヘッダーテーブル (PHT) が役割をはたします。

<Figure 1. ELF structur in two different point of view.> (省略)


B. セクションヘッダーテーブルを調べる

ではどのようなセクションがプログラムの中にあるか見てみましょう。（結果は省略してあります）

$ readelf -S test
There are 28 section headers, starting at offset 0x80c:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
........
  [ 4] .dynsym           DYNSYM          08048174 000174 000060 10   A  5   1  4
........
  [11] .plt              PROGBITS        08048290 000290 000030 04  AX  0   0  4
  [12] .text             PROGBITS        080482c0 0002c0 0001d0 00  AX  0   0 1
........
  [20] .got              PROGBITS        080495d8 0005d8 000004 04  WA  0   0  4
  [21] .got.plt          PROGBITS        080495dc 0005dc 000014 04  WA  0   0  4
  [22] .data             PROGBITS        080495f0 0005f0 000010 00  WA  0   0  4
  [23] .bss              NOBITS          08049600 000600 000008 00  WA  0   0  4
........
  [26] .symtab           SYMTAB          00000000 000c6c 000480 10     27  2c  4
........

.text セクションはコンパイラーが実行可能コードを配置する場所です。　結果としてこのセクションは実行可能とマークされます ("X" が Flg フィールドにつきます)。　このセクションで、 main 関数の機械語命令を見ることができます。：

$ objdump -d -j .text test

-d は objdump に機械語コードの逆アセンブルを、 -j は objdump に特定のセクションのみに注目するよう (ここでは .text セクション) 指示します。

08048370 :.......
 8048397:       83 ec 08             sub     $0x8,%esp
 804839a:       ff 35 fc 95 04 08    pushl   0x80495fc
 80483a0:       68 c1 84 04 08       push    $0x80484c1
 80483a5:       e8 06 ff ff ff       call    80482b0
 80483aa:       83 c4 10             add     $0x10,%esp
 80483ad:       83 ec 08             sub     $0x8,%esp
 80483b0:       ff 35 04 96 04 08    pushl   0x8049604
 80483b6:       68 d3 84 04 08       push    $0x80484d3
 80483bb:       e8 f0 fe ff ff       call    80482b0
.......

.data セクションはプログラム中でスタックには含まれない初期化されたすべての変数を格納します。　"初期化された" のここでの意味は、さきのコードで "global_data" にしたように初期値を与えたということです。　では "local_data" はどうなったでしょう？　はい、 local_data の値はこの .data セクションにはありません。　というもの、 local_data はプロセスのスタックにあるからです。

.data セクションについて objdump で確認できるものは次の通りです。：

$ objdump -d -j .data test
.....
080495fc :
 80495fc:       04 00 00 00
 .........

ここから、 objdump はアドレスからシンボルへの変換をしてくれるということがわかります。　シンボルテーブルをみることなく、 0x08049424 が global_data のアドレスだとわかります。　ここで 4 に設定されていることがわかります。　覚えておいていただきたいのですが、ほとんどの Linux ディストリビューションにインストールされている実行可能形式はストリップされているため、シンボルテーブルのエントリーはありません。　このため objdump によるアドレス解釈は難しくなっています。

では .bss は何でしょうか？　BSS (Block Started by Symbol) は未初期化変数がマッピングされるセクションです。　「なんにでも確実に初期値があるはずだ」とおもわれるかもしれません。　実際、 Linux においては未初期化変数はすべて 0 に設定されています。　よって .bss セクションはゼロで埋まっています。　文字型の変数ではナル文字になります。　このことから実行時に global_data_2 は 0 になることがわかります。：

$ objdump -d -j .bss test
Disassembly of section .bss:
.....
08049604 :
 8049604: 00 00 00 00
 .........

少し前に、シンボルテーブルについて少し触れました。　このテーブルはシンボル名 (外部の関数や変数でない) とアドレスの関係を見出すために使えます。　-s を readelf にわたすと、シンボルテーブルを参照できます。

$ readelf -s test
Symbol table '.dynsym' contains 5 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
......
     2: 00000000    57 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.0 (2)
......
Symbol table '.symtab' contains 72 entries:
......
    49: 080495fc     4 OBJECT  GLOBAL DEFAULT   22 global_data
......
    55: 08048370   109 FUNC    GLOBAL DEFAULT   12 main
......
    58: 00000000    57 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.0
......
    61: 08049604     4 OBJECT  GLOBAL DEFAULT   23 global_data_2
......

"Value" はシンボルのアドレスをあらわします。　たとえば命令語がこのアドレスを参照すると (e.g: pushl 0x80495fc)、これは global_data を参照したことになります。　printf() の扱いは別です。　というのもこのシンボルは外部の関数を参照するからです。　printf はわれわれのプログラムでなく glibc に定義されていることをおもいだしてください。　あとで printf を呼びだす仕組みも説明します。


C. プログラムヘッダーテーブル (PHT) を調べる

先に説明したように、セグメントはオペレーティングシステムがプログラムを把握する方法です。　ではプログラムがセグメント化されるところを見てみましょう。

$ readelf -l test
......

There are 7 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
[0]  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4
[1]  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
[2]  LOAD           0x000000 0x08048000 0x08048000 0x004fc 0x004fc R E 0x1000
[3]  LOAD           0x0004fc 0x080494fc 0x080494fc 0x00104 0x0010c RW  0x1000
[4]  DYNAMIC        0x000510 0x08049510 0x08049510 0x000c8 0x000c8 RW  0x4
[5]  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4
[6]  STACK          0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame 
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.ABI-tag .note.gnu.build-id 
   06     

注意： 各 PHT エントリーの左に数字を付加して、読者がセクションからセグメントへのマッピングを簡単に読み取れるようにしました。

マッピングはすばらしく実直です。　たとえばセグメント番号 2 には 15 のセクションがマッピングされています。　.text セクションはここにマッピングされています。　ここのフラグは R と E で、それぞれ読み取り可能と実行可能を意味します。　W フラグが付されたセグメントは書き込み可能ということです。

"VirtAddr" 列を見ると、各セグメントの開始仮想アドレスがわかります。　セグメント番号 2 では 0x0804800 が開始アドレスです。　本節のあとで、このアドレスがメモリー上の実アドレスでないことがわかります。　PhysAddr は無視してください。　というのも Linux はつねにプロテクトモードで動作する (Intel/AMD の 32/64 ビットシステム上で) からで、そこでは仮想アドレスが本質だからです。

セグメントにはたくさんの型がありますが、ふたつの型にしぼってみてみましょう。：

・LOAD： セグメントの内容は実行可能ファイルからロードされる。　「Offset」はカーネルがファイル内容の読み取りを開始するオフセット位置を示す。　「FileSiz」からはファイルから何バイト読み取られるかがわかる。
　たとえばセグメント 2 の内容はファイルの 0 から 4fc (offset + filesiz) である。　実行速度をあげるため、ファイル内容は必要になってから読み込まれる。　つまり実行時に参照されてはじめてディスクアクセスが発生する。

・STACK： スタック領域をあらわすセグメント。　"Flg" と "Align" 以外のふぃr-る度がすべて 0 になっていることが目を引く。　エラーではないか？　いや、これが正しい。　スタックセグメントがどこからはじまり、どれだけの大きさになるかを決めるのはカーネルの仕事だ。　インテル互換プロセッサーではスタックは下方に成長する（アドレスは値がプッシュされるごとに差し引かれる）。

プロセスの実際のセグメントレイアウトを見たくならないでしょうか？　これは /proc/<pid>/maps ファイルで確認できます。　<pid> は確認したいプロセスの PID です。　先に進む前に小さな問題があります。　テストプログラムはすぐに終了してしまうため、 /proc の関連エントリーをダンプすることができないのです。　ここでは gdb を使って解決ましょう。　ほかにも return する前に sleep() を入れるといったトリックも使えそうです。

コンソール、あるいは xterm のような端末エミュレーターで次のように実行します。：

$ gdb test
(gdb) b main
Breakpoint 1 at 0x8048376
(dgb) r
Breakpoint 1, 0x08048376 in main ()

ここで別のコンソールを開き、 "test" プログラムの PID を探します。　次のようにタイプするのが簡単です。：

$ cat /proc/`pgrep test`/maps

こんな出力が得られるでしょう（別の出力になることもあります）。：

[1] 0039d000-003b2000 r-xp 00000000 16:41 1080084 /lib/ld-2.3.3.so
[2] 003b2000-003b3000 r--p 00014000 16:41 1080084 /lib/ld-2.3.3.so
[3] 003b3000-003b4000 rw-p 00015000 16:41 1080084 /lib/ld-2.3.3.so
[4] 003b6000-004cb000 r-xp 00000000 16:41 1080085 /lib/tls/libc-2.3.3.so
[5] 004cb000-004cd000 r--p 00115000 16:41 1080085 /lib/tls/libc-2.3.3.so
[6] 004cd000-004cf000 rw-p 00117000 16:41 1080085 /lib/tls/libc-2.3.3.so
[7] 004cf000-004d1000 rw-p 004cf000 00:00 0
[8] 08048000-08049000 r-xp 00000000 16:06 66970 /tmp/test
[9] 08049000-0804a000 rw-p 00000000 16:06 66970 /tmp/test
[10] b7fec000-b7fed000 rw-p b7fec000 00:00 0
[11] bffeb000-c0000000 rw-p bffeb000 00:00 0
[12] ffffe000-fffff000 ---p 00000000 00:00 0

注意： 参照しやすくするため各行に番号を振りました。

gdb にもどってタイプしてください。：

(gdb) q

全部で 12 のセグメント（あるいは仮想メモリー領域 VMA とも呼ばれます）を確認できました。　最初と最後のフィールドに注目しましょう。　最初のフィールドは VMA アドレスの範囲を示し、最後のフィールドは背後のファイルを示しています。　VMA 8 と PHT のセグメント 2 に似通った点があることがわかりますか？　違いは SHT が 0x080484fc で終わるとあることに対し、 VMA 8 は 0x08049000 で終わっていることです。　同じことが VMA 9 とセグメント 3 にも言えます。　SHT は 080494fc で始まっていることに対し VMA は 0x0804900 で始まっています。

調べておくべきいくつかの事実があります。

1. VMA が異なるアドレスから開始しているが、関連するセクションは仮想アドレス上にきちんとマッピングされる。
2. カーネルはページごとにメモリーを割り当て、ページサイズは 4KB である。　よって VMA 9 のページアドレスは 0x0804900 となる。　技術的にはセグメントアドレスは近傍のページ境界に丸められる。

最後に、どれがスタックでしょうか？　VMA 11 です。　通常、カーネルは動的にいくつかのページを割り当て、ユーザー空間で可能な最高位の仮想アドレスをスタック領域にマッピングします。　単純化すると、各プロセスのアドレス空間はふたつに分割されます（インテル互換の 32 ビットプロセッサー上と仮定して）： ユーザー空間とカーネル空間のふたつに。　ユーザー空間は 0x00000000-0xc0000000 の範囲で、カーネル空間は 0xc0000000 から上位に向かって確保されます。

さて、これでスタックが 0xc0000000 境界の近傍に割り付けられることが明確になりました。　最終アドレスは固定されており、開始アドレスはスタック上に格納された値の数によって変化します。


D. 関数はどのように参照されるのか？

プログラムが実行可能形式それ自身が抱える関数を呼ぶなら、なされるべきことは単純です。：　手続きを呼びだすだけです。　では glibc 共有ライブラリーに定義されている printf() のような関数を呼びだす場合はどうでしょうか？

ここではダイナミックリンカーがどのように働くかを深くは議論しません。　代わりに呼び出しメカニズムが実行可能形式それ自身の中でどのように実装されているかに注目します。　これを心に留めつつ、先に進みましょう。

プログラムが関数を呼びだそうとすると、実際には次のように処理が進みます。：
1. PLT (Procedure Linkage Table) の対応するエントリーにジャンプします。
2. PLT 内で、次のジャンプをします。飛び先は GOT (Global Offset Table) の関連エントリーに記述されています。
3. これが最初の関数呼び出しならば 4. に、二回目以降なら 5. に進みます。
4. 関連付けられた GOT エントリーには PLT 内の次の命令を指すアドレスが入っています。　プログラムはこのアドレスにジャンプし、ダイナミックリンカーを呼び出し関数のアドレスを解決します。　関数が見つかると、このアドレスは対応する GOT エントリーに格納され、それから関数が実行されます。
5. GOT に書かれたアドレスにジャンプします。　これは関数のアドレスのため、ここにおいて PLT は不要です。
6. 関数の実行が終了すると、メインプログラムの次の命令にジャンプします。

いつものとおり、実行可能形式の中を覗いてみることが説明に役立つでしょう。　次のようにすると、：

$ objdump -d -j .text test

次のようなコード片が表示されます。：

.....
08048370 :
.....
 804838f: e8 1c ff ff ff call 80482b0

0x80482b0 は次のようになっています。：

080482b0 :
 80482b0: ff 25 ec 95 04 08 jmp *0x80495ec
 80482b6: 68 08 00 00 00 push $0x8
 80482bb: e9 d0 ff ff ff jmp 8048290 <_init+0x18>

見てのとおり、 0x80482b0 でのジャンプは相対ジャンプ ('*' がアドレスに前置されます) です。　ではどこに飛ぶか 0x804820 を見てみましょう。　おそらく .got セクションか .got.plt セクションにあるアドレスでしょう。　SHT を再確認すると .got.plt を見るべきだとわかります。　ここでは readelf を 16 進ダンプに使います。というのもエンディアンの並べ替えをしてくれるからです。：

$ readelf -x 21 test
Hex dump of section '.got.plt':
 0x080495dc 080482a6 00000000 00000000 08049510
 ................
 0x080495ec 080482b6
 ....

(注意：最初の列は仮想アドレスです。　このアドレスのデータは 5 列目です。　2 列目ではありません！　つまり右から左に昇順で並んでいます。)

ビンゴ！　"080482b6" がここにありました。　言いかえると、 PLT に戻ってから、別のアドレスへジャンプしたわけです。　そこからはダイナミックリンカーが処理するところなのでスキップしましょう。　ダイナミックリンカーが魔法の仕事を終えると、対応する GOT エントリーには printf() のアドレスが書かれているでしょう。


E. ELF 構造を探る別のツール

信頼に足るのは readelf と objdump だけでなく、 Beya という別のツールもあります。　実際にはファイルビューワーですが、 ELF 構造を解析するためにも使えます。　ソースコードは htp://beya.sourceforge.net から入手でき、自分でコンパイルできます。　Beya はハッキング向けの Linux Live CD、 たとえば Phlak などにも含まれています。　ウェブサイトやパッケージのドキュメントを参照して Beya のコンパイルやインストールをしてください。

個人的に Beya を気に入っているのは curses を使った GUI を提供しているからです。　セクション間の移動や ELF ヘッダーの確認、シンボルの列挙、その他のタスクが、いくつかのキーボードショートカットを押すだけで終わるのです。

たとえばシンボルを列挙して直接シンボルのアドレスにジャンプできます。　実際に main() にジャンプしてみましょう。　まず Beya を実行します。

$ beya test

Ctrl+A を押して F7 を押すとシンボルテーブルを参照できます。　テーブルを横断して時間を無駄にしないよう F7 をもう一度押して "Find string" メニューを開きます。　"main" とタイプして Enter を押します。　ハイライトされたエントリーが探しているものなら、 Enter を押して main() のアドレスにジャンプできます。　逆アセンブルモードに切り替える (F2 で選択します) ことを忘れなければ、命令語の翻訳結果が参照できます。

<Figure 2. Beya が全シンボルを列挙している>

ファイルオフセットでなく仮想アドレスで考えていたので、仮想アドレスビューに切り替えるのがいいでしょう。　Ctrl+C につづけて F6 を押し "Local" を選択します。　これで左端の列が仮想アドレスになります。


まとめ

この記事は ELF 構造を調べるための概説です。　readelf と objdump を使った探索の準備ができました。　必要なら Beya を使うことでバイナリーの中を素早く渉猟できます。　手持ちの武器はなんでも使い、創造的にそして常に慣れ親しんでいればすぐに技術をものにできます。　さあ、楽しい冒険を。


高度な読み物
・http://www.linuxjournal.com/article/1059
　http://www.linuxjournal.com/article/1060
　Eric Youngdale による、すばらしい ELF の導入記事二本。

・http://en.wikipedia.org/wiki/Executable_and_Linkable_Format
　Wikipedia の ELF 解説。　ここには別の有用な文書へのリンクがあります。

・http://x86.ddj.com/ftp/manuals/tools/elf.pdf
　ELF 構造の完全な解説文書。　本記事を読んでからこの文書を調べると ELF を完璧に理解できます。

・ELFSH <http://elfsh.devhell.org/>
　ELF バイナリーを調べ、操作するためのツール。　リバースエンジニアリングするためにもすばらしく有用です。　スクリプト機能もあるので多くの作業を自動化できます。　ウェブサイトにはたくさんの ELF ハックの解説文書があります。
