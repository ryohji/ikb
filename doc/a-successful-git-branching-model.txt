<http://nvie.com/posts/a-successful-git-branching-model/>

この記事で、ぼくは開発モデルを紹介しよう。これはぼくが一年前からプロジェクトすべて（仕事と趣味とに）に導入しているもので、とてもうまくいくとわかったものだ。これについてちょっとだけ書いておくつもりだけれど、今にいたるまでちっとも時間がみつけられない。ここではプロジェクトの詳細は語らずに、ブランチをつくる戦略やリリース管理について述べるつもりだ。

これはソースコードをバージョン管理するツール、 Git に焦点をあてた文書だ。


* なぜ Git なのか？
ソースコードの集中管理システムと比較した Git の長所と短所について徹底的な議論は Web を参照してもらいたい。 (http://git.or.cz/gitwiki/GitSvnComparsion) いやになるほどのフレーム戦争が進行中だ。開発者としていえば、ぼくは今日つかえるツールの中で Git が一番いいとおもっている。 Git は、ブランチとマージについての開発者の考え方を根本的に変える。かつてぼくが使っていた古典的な CVS/Subversion の世界では、マージとブランチはいつだってちょっぴり怖いものだったし（「マージのコンフリクトに気をつけて。かみつかれるよ！」）、ほとんどすることはない作業だった。

でも Git なら、マージやブランチはとんでもなく簡単で単純だ。そして毎日の作業フローのコア部分のひとつだと感じられるようになる。たとえば CVS/Subversion の解説書では、ブランチやマージの解説は後ろの章（熟練したユーザー向け）になってはじめてあらわれるのに対し、 Git の解説書では 3 章までの基本でカバーされている。

この単純さと反復の結果、ブランチやマージはもはや恐れるものではなくなってしまう。バージョン管理ツールはなににもましてブランチやマージを手助けするものだと考えられるわけだ。

さあ、ツールについては十分だろう。開発モデルに目を向けよう。ここでぼくが述べるモデルはとても基本的なもので、チームンバー全員が管理されたソフトウェア開発モデルに到達するための諸手順にまさるものではない。


* 分散化されつつも集中される
ぼくらが使うこのブランチモデルでうまく機能するリポジトリーのセットアップでは、中央の "truth" repo がいる。この repo は、ただ真ん中にあるとみなしたものにすぎないということに注意してほしい（というのも Git は分散バージョン管理システムであり、技術的にこれが中央リポジトリーになるというものは存在しないから）。ぼくらはこの repo を origin として参照する。この名前は Git ユーザー全員になじみ深いものだ。

各開発者は origin から pull し、 push する。ただし集権化された push-pull 関係にくわえて、各開発者は別の開発者から変更箇所を pull でき、これによってサブチームを形作ることもある。たとえば二人から数人の開発者で大きな機能に取り組んでいるとき、不完全な進行中の作業を origin に push する以前に役立てられる。上の図では、アリスとボブ、アリスとデイビッド、それからクレアとデイビッドのサブチームがある。

技術的には、アリスは bob という名前の Git remote を定義してボブのリポジトリーを参照しており、ボブも逆にそうしているというだけに過ぎない。


* メインブランチ (main branches)
コアとしては、この開発モデルはそこここの既存のモデルに大いに影響されている。中央リポジトリーはふたつのメインブランチを保持する。このふたつは無期限の生存期間を持つ master と develop である。
origin の master ブランチは Git ユーザーならなじみ深いものだとおもう。 master ブランチとならんで develop というもうひとつのブランチがある。

ぼくらは origin/master を、その HEAD ソースコードが出荷可能状態を反映したメインブランチだと考える。

origin/develop は、その HEAD が次のリリースにいれる予定の開発中の変更点を反映したブランチだと考える。人によってはこれを "結合ブランチ" と呼ぶだろう。これは自動夜間ビルドが参照するブランチでもある。

develop ブランチのソースコードが安定してリリース準備ができたら、変更点はどうにかして master にマージされて、リリース番号とともにタグ付けられる。どのようにしてかの詳細はもっと先で説明しよう。

よって、 master に変更点がマージされるときが新しいリリースだということになる。これについてぼくらはとても厳格で、理論的には Git フックスクリプトで、 master にコミットがされるごとに、自動的にビルドしプロダクションサーバーにソフトウェアを配備することができる。


* サポート用ブランチ
main と develop ブランチにならんで、ぼくらの開発モデルでは種々のサポート用ブランチを使って、チームメンバー間の並行開発をたすけ、機能を簡単に追跡し、製品リリースの準備をし、製品で生じた問題の早期修正を補助したりしている。メインブランチとは違い、これらのブランチは限られた時間しか存在せず、いつの日か削除される。

ぼくらが使うことになるブランチはざっとこんなものだ。：
・機能ブランチ
・リリース用ブランチ
・ホットフィックスブランチ

これらのブランチには特定の目的があり、分岐もとのブランチがどれでマージされるターゲットがどこかを決める厳格なルールにしたがっている。ではちょっとずつ眺めていこう。

技術的観点からはこれらのブランチになんら特別なところはない。ブランチの種別はぼくらがこれらをどう使うかでカテゴリーわけされている。いずれもたんなる Git ブランチにすぎない。


** 機能ブランチ (Feature branches)
ブランチするのは: develop
マージされるのは: develop
ブランチ命名規則: 次を除きなんでも可。 master, develop, release-*, hotfix-*

機能ブランチ（ときとしてトピックブランチとも呼ばれる）は、次の、あるいははるか先のリリースに向けての新機能を開発するために使われる。機能開発をはじめるときは、その時点でこの機能がいつのリリースにはいるか不明なこともある。機能ブランチのエッセンスは、機能が開発中である限り存在し続け、いつか develop にマージされる（来たるリリースに新機能を付けくわえるために）。あるいは破棄される（心痛む実験として）。

典型的には機能ブランチは開発者の repo にのみ存在し origin には存在しない。


*** 機能ブランチの作成
新機能を開発しはじめるときは、 develop ブランチからブランチを切る。

$ git checkout -b myfeature develop
Switched to a new branch "myfeature"

*** 開発完了した機能を develop に戻す
開発完了した機能は develop ブランチにマージされ、来たるリリースで追加されるだろう。

$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff myfeature
Updating ea1b82a..05e9557
(Summary of changes)
$ git branch -d myfeature
Deleted branch myfeature (was 05a9557).
$ git push origin develop

--no-ff フラグによって、マージで新しいコミットオブジェクトが作成されることになる。このマージが fast-forward で可能な場合であっても。こうすることで過去に機能ブランチが存在したこと、グループで機能を追加したという情報を失わずに済む。比較してみよう。：

（図）

後者だと（通常の git merge による）、 Git の履歴からでは、どのコミットオブジェクトが機能を実装したものかを読み取れない。つまりすべてのログをひとつひとつ読み取らなければならなくなる。機能を取り除くには（ということはコミットのグループを）、後者の状況では頭痛の種だが、 --no-ff フラグを使っていればとても簡単だ。そう、これはいくつか（からっぽの）コミットオブジェクトをつくるけれども、見返りはコストより大きい。

残念なことに --no-ff を git merge の規定動作にする方法はわからない。けれど、これはそうすべきである。


** リリース用ブランチ (Release branches)
ブランチするのは: develop
マージされるのは: develop および master
ブランチ命名規則: release-*

リリース用ブランチは新たな製品リリースの準備につかう。これによって i's から t's への点線を結ぶ最後の時間がとれる。さらには小さなバグ修正やリリースに向けてのメタデータの準備（バージョン番号、ビルド日時、その他）にも使える。これらの作業はすべてリリースブランチ向けのもので、 develop ブランチは次の大きなリリース向けに機能を受けつけるべくきれいにされる。

develop ブランチから新たなリリース用ブランチを切る肝心な瞬間は、開発が新たなリリースに向けて望まれる状態をほぼ反映したときだ。最低限、リリースのためのビルドに向けたすべての機能が、この時点の develop ブランチにマージされている必要がある。さらに先のリリースに向けた機能ははいっていなくてよい。これらはリリース用ブランチを切り終わるまで待たせておく。

次のリリースがバージョン番号を割り付けられたときが、リリース用ブランチの正式なはじまりだ。それより前ではない。そのときまでは develop ブランチは「次のリリース」を反映しているけれど、「次のリリースが」 0.3 なのか 1.0 なのかは、リリース用ブランチがはじまるまでは不明確だ。この決定はリリース用ブランチをはじめるときに決定がなされ、バージョン番号付与のプロジェクトルールが実行される。

*** リリース用ブランチの作成
リリース用ブランチは develop ブランチから作成される。たとえば、そう、バージョン 1.1.5 が現時点の製品リリースで、ビッグリリースが近づいているとしよう。 develop は「次のリリース」準備がととのっている状態で、ぼくらはこれをバージョン 1.2 とすることに決めた（1.1.6 でなく、 2.0 でもなく）。よってぼくらはブランチを切り、そのリリース用ブランチの名前にバージョン番号を含める。：

$ git checkout -b release-1.2 develop
Switched to a new branch "release-1.2"
$ ./bump-version.sh 1.2
Files modified successfully, version bumped to 1.2.
$ git commit -a -m "Bumped version number to 1.2"
[release-1.2 74d9424] Bumped version number to 1.2
1 files changed, 1 insertions(+), 1 deletions(-)

新しいブランチを切ってスイッチすると、ぼくらはバージョン番号を付する。ここでは bump-version.sh は架空のシェルスクリプトで、作業コピーのいくつかのファイルを変更し、新しいバージョン番号を反映させる。（もちろん手で変更してもいい。ポイントはいくつかのファイルが変わるということだ）そして、埋め込まれたバージョン番号がコミットされる。

この新ブランチがあるのは少しの間だけ、リリースが完全にロールアウトされるまでだ。その間、バグ修正がこのブランチに適用されることもある（develop ブランチにではなく）。大きな機能追加は絶対になしだ。これらは develop にマージされるべきで、よって次のリリースまで待たされる。

*** リリース用ブランチを片づける
リリース用ブランチがほんとうのリリースに向けて準備状態になったら、いくつかすべきことがある。まず、リリースブランチを master にマージする（おもいだしてほしい。 master へのコミットはすべてリリースであると定義した）。それから、 master へのこのコミットをタグ付けして、将来、このバージョンをかんたんに参照できるようにする。最後に、このリリース用ブランチに加えた変更を develop ブランチにもマージし、将来のリリースがこれらのバグ修正を含むようにする。

最初のふたつのステップは Git ではこうなる。：

$ git checkout master
Switched to branch 'master'
$ git merge --no-ff release-1.2
Merge made by recursive.
(Summary of changes)
$ git tag -a 1.2

リリースはこれで完了。そして将来の参照用のタグもついた。
編集！：あなたは -s や -u <key> フラグをつけて、タグにあなたの署名をつけておくこともできる。

リリース用ブランチでの変更を保存するために、これらを develop ブランチにもマージする必要がある。 Git で、：

$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff release-1.2
Merge made by recursive.
(Summary of changes)

このステップはマージの衝突を引き起こすことがある（おそらくきっと。というのもバージョン番号を変えているから）。この場合、これを修正してコミットする。

これでほんとうにリリースが完了した。もう、これに対してすることは残っていないのでリリース用ブランチを取り除くことができる。：

$ git branch -d release-1.2
Deleted branch release-1.2 (was ff452fe).


** ホットフィックスブランチ (Hotfix branches)
ブランチするのは： master
マージされるのは： develop および master
ブランチ命名規則： hotfix-*

ホットフィックスブランチはリリースブランチによく似ている。というのも不測のこととはいえ、これらもまた新しい製品リリース用に準備するものだからだ。これらは実製品の望ましからぬ状態に、早急に対処するためのものだ。製品バージョンでの緊急のバグはすみやかに解決せねばならず、ホットフィックスブランチは master ブランチの製品バージョンを記された対応するタグからブランチされる。

このエッセンスは、ある担当者が緊急製品フィックスを準備している間も、 (develop ブランチ上にいる) 開発メンバーは作業を継続できることだ。

*** ホットフィックスブランチをつくる
ホットフィックスブランチは master ブランチからつくる。たとえば、バージョン 1.2 が現時点の製品リリースで、いくつかのバグで問題を起こしているとしよう。しかし develop ブランチ上の変更はまだ不安定である。ぼくらは問題を修正すべくホットフィックスブランチを切る。：

$ git checkout -b hotfix-1.2.1 master
Switched to a new branch "hotfix-1.2.1"
$ ./bump-version.sh 1.2.1
Files modified successfully, version bumped to 1.2.1.
$ git commit -a -m "Bumped version number to 1.2.1"
[hotfix-1.2.1 41e61bb] Bumped versoin number to 1.2.1
1 files changed, 1 insertions(+), 1 deletions(-)

ブランチを切ったら、バージョン番号を変えるのを忘れないこと！

そしてバグを修正し、その修正をひとつ、あるいはいくつかのコミットで修正する。

$ git commit -m "Fixed severe production problem"
[hotfix-1.2.1 abbe5d6] Fixed severe production problem
5 files changed, 32 insertions(+), 17 deletions(-)

*** ホットフィックスブランチを終了する
作業が完了したら、バグ修正は master にマージされなければならない。そして次以降のリリースでもこのバグ修正がはいって安全になるように develop にもマージされる必要がある。これはリリース用ブランチの完了時とほんとうによく似ている。

まず master を更新してリリース用のタグをつける。

$ git checkout master
Switched to branch 'master'
$ git merge --no-ff hotfix-1.2.1
Merge made by recursive.
(Summary of changes)
$ git tag -a 1.2.1

編集！：あなたは -s や -u <key> フラグを使って暗号化による署名をつけられる。

それから develop ブランチにもバグ修正をいれる。：

$ git checkout develop
Switched to branch 'develop\
$ git merge --no-ff hotfix-1.2.1
Merge made by recursive.
(Summary of changes)

ただひとつ例外があって、リリース用ブランチがいっしょにあるなら、ホットフィックスによる変更はリリース用ブランチにマージし、 develop ブランチにはいれない。リリース用ブランチへいれたバグ修正は、リリース用ブランチが完了する時点で develop へのバグ修正としてマージされる。（もし develop での作業が即座にバグ修正が必要で、リリース用ブランチの完了を待てないなら、 develop へもマージしてもよい）

最後に、この一時的なブランチを削除する。：

$ git branch -d hotfix-1.2.1
Deleted branch hotfix-1.2.1 (was abbe5d6).


* まとめ
衝撃的にあたらしいことは、このブランチモデルにはないけれど、この記事からはじまる「大きな絵」は、ぼくらのプロジェクトではとても有用なことがわかった。これは容易に理解できるエレガントなメンタルモデルをかたちづくり、チームメンバーの間にブランチとリリースのプロセスに関する共通理解をつくりあげることができた。

高品質の PDF をここに載せておく。印刷していつでも参照できるよう壁に貼っておいてほしい。
<http://github.com/downloads/nvie/gitflow/Git-branching-model.pdf>

更新：それから欲しい人へ。 Apple Keynote 形式での主たる図はここに置いた。
<http://github.com/downloads/nvie/gitflow/Git-branching-model-src.key.zip>
